.program rx

;;---------------------------------------------------
;; Measure the delay between the falling edges of the
;; transmitted and received signals.
;; Accumulate the count over a certain number of
;; carrier periods then send it via the RX FIFO.
;; Synchronise with the TX program using IRQ 7.
;;---------------------------------------------------

; send result to RX FIFO
send_result:
    MOV ISR, !X         ; invert sign of counter
    PUSH noblock

; initialise counters
PUBLIC entry:
    SET X, 0            ; reset counter
    SET Y, 16           ; carrier periods to count over

; carrier cycle loop
.wrap_target

; synchronise to falling edge of carrier
    WAIT 1 IRQ 7        ; wait for IRQ and clear it

; count until RX is high
rx_low:
    JMP PIN rx_high     ; jump out if RX is high
    JMP X-- rx_low      ; decrement counter

; count until RX falling edge
rx_high:
    JMP X-- over        ; decrement counter
over:
    JMP PIN rx_high     ; loop while RX remains high

; accumulate count over several periods of carrier
next_cycle:
    JMP Y-- send_result ; branch if Y was zero
.wrap

;; 10 instructions, 4 instructions per carrier period


% c-sdk {
static inline void rx_sm_init (PIO pio, uint sm, uint offset, uint gpio) {
    // create and initialise a state machine configuration
    pio_sm_config config = rx_program_get_default_config (offset);

    // define the raw GPIO to be used for JMP PIN
    sm_config_set_jmp_pin(&config, gpio);

    // join the FIFOs for receive
    sm_config_set_fifo_join(&config, PIO_FIFO_JOIN_RX);

    // run the state machine at full speed
    sm_config_set_clkdiv_int_frac (&config, 1, 0);

    // apply the configuration to the state machine and initialise program counter to 'entry'
    pio_sm_init (pio, sm, offset + rx_offset_entry, &config);

    // allow the state machine to run
    pio_sm_set_enabled (pio, sm, true);
}
%}